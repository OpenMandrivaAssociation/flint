--- ./packed_vec.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./packed_vec.c	2012-05-07 12:12:40.200459177 -0600
@@ -173,7 +173,7 @@ void pv_set_bits(pv_s * vec, int bits)
 #endif
 		PV_ITER_INIT(iter2, *vec, 0);
      
-      ulong temp;
+		ulong temp = 0;
 		
 		ulong i;
 		for (i = 0; i < vec->length; i++)
--- ./F_mpz_LLL.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./F_mpz_LLL.c	2012-05-07 12:12:40.202459175 -0600
@@ -3321,13 +3321,13 @@ int knapsack_LLL_d_with_removal(F_mpz_ma
    int * copy_expo, * copy_alpha;
 
    int ok = 1;
-   int newd = d;
+   int newd;
    double d_rii;
    double d_gs_B;
    ulong exp;
 
    n = B->c;
-   d = B->r;
+   d = newd = B->r;
    D = d;
 
    ctt = (4*DELTA + 1)/5;
--- ./theta.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./theta.c	2012-05-07 12:12:40.203459174 -0600
@@ -75,7 +75,7 @@ void theta_fprint(long * coeff, ulong st
             fprintf(f, "*");
 
         if (n == 1)
-            fprintf(f, "q", n);
+            fprintf(f, "q");
 
         if (n > 1)
             fprintf(f, "q^%ld", n);
--- ./fmpz_poly.c.orig	2012-05-07 12:12:30.214469227 -0600
+++ ./fmpz_poly.c	2012-05-07 12:12:40.207459170 -0600
@@ -216,7 +216,7 @@ void fmpz_poly_bit_pack(fmpz_t array, co
          
    while (coeff_m < last_point)
    {
-      if ((ulong) coeff_m & 7 == 0) FLINT_PREFETCH(coeff_m, 64);
+      if ((((ulong) coeff_m) & 7) == 0) FLINT_PREFETCH(coeff_m, 64);
       // k is guaranteed to be less than FLINT_BITS at this point
       while ((k < HALF_FLINT_BITS) && (coeff_m < last_point))
       {
@@ -390,7 +390,7 @@ void fmpz_poly_bit_unpack_unsigned(fmpz_
       
    while (coeff_m < next_point)
    {
-      if (skip & 7 == 0) FLINT_PREFETCH(array + skip, 64);
+      if ((skip & 7) == 0) FLINT_PREFETCH(array + skip, 64);
       // read in a full limb
       full_limb = array[skip];
       temp2 += l_shift(full_limb,k);
@@ -1764,7 +1764,7 @@ long _fmpz_poly_max_bits1(const fmpz_pol
    
    for (i = 0, j = 0; i < poly_fmpz->length; i++, j += 2)
    {
-      if (i&3 == 0) FLINT_PREFETCH(coeffs_m+j,64);
+      if ((i&3) == 0) FLINT_PREFETCH(coeffs_m+j,64);
       if ((long) coeffs_m[j] < 0) sign = -1L;
       if (coeffs_m[j])
       {
--- ./flint.h.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./flint.h	2012-05-07 12:12:40.208459169 -0600
@@ -142,7 +142,7 @@ Cache size in bytes.
 
 #define FLINT_POL_DIV_1_LENGTH 10
 
-#define ulong unsigned long
+typedef unsigned long ulong;
 
 #if FLINT_BITS == 32
 #define half_ulong uint16_t
--- ./fmpz.h.orig	2012-05-07 12:12:30.218469223 -0600
+++ ./fmpz.h	2012-05-07 12:12:40.209459168 -0600
@@ -383,7 +383,7 @@ fmpz_t ** fmpz_comb_temp_init(fmpz_comb_
 
 void fmpz_comb_temp_clear(fmpz_t ** temp, fmpz_comb_t comb);
 
-unsigned long fmpz_multi_mod_ui_basecase(unsigned long * out, fmpz_t in, 
+void fmpz_multi_mod_ui_basecase(unsigned long * out, fmpz_t in, 
                                unsigned long * primes, unsigned long num_primes);
 
 void fmpz_multi_mod_ui(unsigned long * out, fmpz_t in, fmpz_comb_t comb, fmpz_t ** temp);
--- ./long_extras.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./long_extras.c	2012-05-07 12:12:40.209459168 -0600
@@ -1121,7 +1121,7 @@ unsigned long z_nextprime(unsigned long
 int z_isprime_pocklington(unsigned long const n, unsigned long const iterations)
 {
 	int i, j, k, pass, test, exp;
-	unsigned long sqrt, n1, f, factor, prod, temp, b, c;
+	unsigned long sqrt, n1, f, factor, prod, temp, b, c = 1;
 	factor_t factors;
 	pre_inv_t inv;
 	
--- ./F_mpz_poly.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./F_mpz_poly.c	2012-05-07 12:12:40.212459165 -0600
@@ -2172,7 +2172,7 @@ void F_mpz_poly_bit_pack(mp_limb_t * arr
          
    while (coeff_m < end_point)
    {
-      if ((ulong) coeff_m & 7 == 0) FLINT_PREFETCH(coeff_m, 64);
+      if ((((ulong) coeff_m) & 7) == 0) FLINT_PREFETCH(coeff_m, 64);
 
       // k is guaranteed to be less than FLINT_BITS at this point
       while ((k < HALF_FLINT_BITS) && (coeff_m < end_point))
@@ -2276,7 +2276,7 @@ void F_mpz_poly_bit_pack_unsigned(mp_lim
          
    while (coeff_m < end_point)
    {
-      if ((ulong) coeff_m & 7 == 0) FLINT_PREFETCH(coeff_m, 64);
+      if ((((ulong) coeff_m) & 7) == 0) FLINT_PREFETCH(coeff_m, 64);
 
       // k is guaranteed to be less than FLINT_BITS at this point
       while ((k < HALF_FLINT_BITS) && (coeff_m < end_point))
@@ -2462,7 +2462,7 @@ void F_mpz_poly_bit_unpack_unsigned(F_mp
       
    while (coeff_m < end_point)
    {
-      if (skip & 7 == 0) FLINT_PREFETCH(array + skip, 64);
+      if ((skip & 7) == 0) FLINT_PREFETCH(array + skip, 64);
       // read in a full limb
       full_limb = array[skip];
       temp += l_shift(full_limb, k);
@@ -2527,7 +2527,7 @@ void F_mpz_poly_bit_pack2(mp_limb_t * ar
          
    while (coeff_m < end_point)
    {
-      if ((ulong) coeff_m & 7 == 0) FLINT_PREFETCH(coeff_m, 64);
+      if ((((ulong) coeff_m) & 7) == 0) FLINT_PREFETCH(coeff_m, 64);
 
       // k is guaranteed to be less than FLINT_BITS at this point
       while ((k < HALF_FLINT_BITS) && (coeff_m < end_point))
@@ -3956,8 +3956,8 @@ void _F_mpz_poly_mul_KS2(F_mpz_poly_t ou
    
 	if ((bits - sign <= FLINT_BITS - 2) && (bits1) && (bits2)) bitpack = 1;
    
-   mp_limb_t * int1, * int2, * int1b, * int2b, * int3, * int3b, * int4;
-	ulong n1, n2;
+   mp_limb_t * int1 = NULL, * int2 = NULL, * int1b = NULL, * int2b = NULL, * int3, * int3b, * int4;
+	ulong n1 = 0, n2 = 0;
    
 	if (bitpack)
    {
--- ./profiler.h.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./profiler.h	2012-05-07 12:12:40.213459164 -0600
@@ -32,7 +32,7 @@
 #include <sys/time.h>
 #endif
 #undef ulong 
-#define ulong unsigned long
+typedef unsigned long ulong;
 
 #ifndef FLINT_PROFILER_H
 #define FLINT_PROFILER_H
--- ./long_extras.h.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./long_extras.h	2012-05-07 12:12:40.213459164 -0600
@@ -285,7 +285,6 @@ unsigned long z_intfifthroot(unsigned lo
 unsigned long z_factor_HOLF(unsigned long n, unsigned long iters);
 unsigned long z_factor_trial_extended(unsigned long n);
 void z_compute_extended_primes();
-static inline void z_initialize_extended_primes();
 void insert_factorpower(factor_t * factors, unsigned long p, unsigned long e);
 
 #ifdef __cplusplus
--- ./fmpz.c.orig	2012-05-07 12:12:30.211469230 -0600
+++ ./fmpz.c	2012-05-07 12:12:40.214459163 -0600
@@ -1239,7 +1239,7 @@ void fmpz_comb_clear(fmpz_comb_t comb)
    flint_heap_free(comb->mod);
 }
 
-unsigned long fmpz_multi_mod_ui_basecase(unsigned long * out, fmpz_t in, 
+void fmpz_multi_mod_ui_basecase(unsigned long * out, fmpz_t in, 
                                unsigned long * primes, unsigned long num_primes)
 {
    unsigned long i;
--- ./QS/poly.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./QS/poly.c	2012-05-07 12:12:40.214459163 -0600
@@ -146,7 +146,7 @@ void tiny_compute_A(QS_t * qs_inf, poly_
    unsigned long factor, i, p;
    unsigned long diff, best_diff, best1, best2;
    
-   unsigned long A;
+   unsigned long A = 0;
    
    if (s <= 4) 
    {
@@ -186,6 +186,7 @@ void tiny_compute_A(QS_t * qs_inf, poly_
    
    if (s == 5) 
    {
+       best1 = best2 = best_diff = 0;
        A_ind[0] = ((z_randint(span) + min) | 1);
        if (A_ind[0] == min + span) A_ind[0] -= 2;
        
--- ./QS/linear_algebra.c.orig	2010-12-23 20:45:11.000000000 -0700
+++ ./QS/linear_algebra.c	2012-05-07 12:12:40.214459163 -0600
@@ -133,6 +133,7 @@ int tiny_relations_cmp(const void *a, co
   
   if (ra->data[point] > rb->data[point]) return 1;
   else if (ra->data[point] < rb->data[point]) return -1;
+  return 0;
 }
 
 int tiny_relations_cmp2(const void *a, const void *b)
@@ -152,6 +153,7 @@ int tiny_relations_cmp2(const void *a, c
 
   if (ra->data[point] > rb->data[point]) return 1;
   else if (ra->data[point] < rb->data[point]) return -1;
+  return 0;
 }
   
 /*==========================================================================
--- ./QS/mp_linear_algebra.c.orig	2012-05-07 12:12:33.369466052 -0600
+++ ./QS/mp_linear_algebra.c	2012-05-07 12:12:40.215459162 -0600
@@ -142,6 +142,7 @@ int relations_cmp(const void *a, const v
   
   if (ra->data[point] > rb->data[point]) return 1;
   else if (ra->data[point] < rb->data[point]) return -1;
+  return 0;
 }
 
 int relations_cmp2(const void *a, const void *b)
@@ -161,6 +162,7 @@ int relations_cmp2(const void *a, const
 
   if (ra->data[point] > rb->data[point]) return 1;
   else if (ra->data[point] < rb->data[point]) return -1;
+  return 0;
 }
   
 /*==========================================================================
