diff -up ./nmod_poly/doc/nmod_poly.txt.orig ./nmod_poly/doc/nmod_poly.txt
--- ./nmod_poly/doc/nmod_poly.txt.orig	2013-08-01 13:42:39.976642170 -0300
+++ ./nmod_poly/doc/nmod_poly.txt	2013-08-01 13:45:22.314648387 -0300
@@ -406,7 +406,7 @@ void nmod_poly_mul_classical(nmod_poly_t
     Sets \code{res} to the product of \code{poly1} and \code{poly2}.
 
 void _nmod_poly_mullow_classical(mp_ptr res, mp_srcptr poly1, slong len1, 
-                           mp_srcptr poly2, slong len2, slong trunc, nmod_t mod)
+                          mp_srcptr poly2, slong len2, slong trunc, nmod_t mod)
 
     Sets \code{res} to the lower \code{trunc} coefficients of the product of 
     \code{(poly1, len1)} and \code{(poly2, len2)}. Assumes that 
@@ -414,7 +414,7 @@ void _nmod_poly_mullow_classical(mp_ptr
     output is not permitted.
 
 void nmod_poly_mullow_classical(nmod_poly_t res, 
-                  const nmod_poly_t poly1, const nmod_poly_t poly2, slong trunc)
+                 const nmod_poly_t poly1, const nmod_poly_t poly2, slong trunc)
 
     Sets \code{res} to the lower \code{trunc} coefficients of the product 
     of \code{poly1} and \code{poly2}.
@@ -429,7 +429,7 @@ void _nmod_poly_mulhigh_classical(mp_ptr
     and output is not permitted.
 
 void nmod_poly_mulhigh_classical(nmod_poly_t res, 
-                  const nmod_poly_t poly1, const nmod_poly_t poly2, slong start)
+                 const nmod_poly_t poly1, const nmod_poly_t poly2, slong start)
 
     Computes the product of \code{poly1} and \code{poly2} and writes the 
     coefficients from \code{start} onwards into the high coefficients of 
@@ -452,7 +452,7 @@ void nmod_poly_mul_KS(nmod_poly_t res,
     is computed automatically.
 
 void _nmod_poly_mullow_KS(mp_ptr out, mp_srcptr in1, slong len1,
-                mp_srcptr in2, slong len2, mp_bitcnt_t bits, slong n, nmod_t mod)
+              mp_srcptr in2, slong len2, mp_bitcnt_t bits, slong n, nmod_t mod)
 
     Sets \code{out} to the low $n$ coefficients of \code{in1} of length
     \code{len1} times \code{in2} of length \code{len2}. The output must have
@@ -460,13 +460,13 @@ void _nmod_poly_mullow_KS(mp_ptr out, mp
     and that \code{0 < n <= len1 + len2 - 1}. 
 
 void nmod_poly_mullow_KS(nmod_poly_t res, const nmod_poly_t poly1, 
-                             const nmod_poly_t poly2, mp_bitcnt_t bits, slong n)
+                            const nmod_poly_t poly2, mp_bitcnt_t bits, slong n)
 
     Set \code{res} to the low $n$ coefficients of \code{in1} of length
     \code{len1} times \code{in2} of length \code{len2}. 
 
 void _nmod_poly_mul(mp_ptr res, mp_srcptr poly1, slong len1, 
-                                        mp_srcptr poly2, slong len2, nmod_t mod)
+                                       mp_srcptr poly2, slong len2, nmod_t mod)
 
     Sets \code{res} to the product of \code{poly1} of length \code{len1} 
     and \code{poly2} of length \code{len2}. Assumes \code{len1 >= len2 > 0}.
@@ -478,7 +478,7 @@ void nmod_poly_mul(nmod_poly_t res,
     Sets \code{res} to the product of \code{poly1} and \code{poly2}.
 
 void _nmod_poly_mullow(mp_ptr res, mp_srcptr poly1, slong len1, 
-                                mp_srcptr poly2, slong len2, slong n, nmod_t mod)
+                              mp_srcptr poly2, slong len2, slong n, nmod_t mod)
 
     Sets \code{res} to the first \code{n} coefficients of the 
     product of \code{poly1} of length \code{len1} and \code{poly2} of
@@ -487,13 +487,13 @@ void _nmod_poly_mullow(mp_ptr res, mp_sr
     is permitted.
 
 void nmod_poly_mullow(nmod_poly_t res, const nmod_poly_t poly1, 
-                                           const nmod_poly_t poly2, slong trunc)
+                                          const nmod_poly_t poly2, slong trunc)
 
     Sets \code{res} to the first \code{trunc} coefficients of the 
     product of \code{poly1} and \code{poly2}.
 
 void _nmod_poly_mulhigh(mp_ptr res, mp_srcptr poly1, slong len1, 
-                                mp_srcptr poly2, slong len2, slong n, nmod_t mod)
+                              mp_srcptr poly2, slong len2, slong n, nmod_t mod)
 
     Sets all but the low $n$ coefficients of \code{res} to the 
     corresponding coefficients of the product of \code{poly1} of length 
@@ -529,8 +529,8 @@ void nmod_poly_mulmod(nmod_poly_t res,
     \code{poly2} upon polynomial division by \code{f}.
 
 void _nmod_poly_mulmod_preinv(mp_ptr res, mp_srcptr poly1, slong len1, 
-                          mp_srcptr poly2, slong len2, mp_srcptr f,
-                          slong lenf, mp_srcptr finv, slong lenfinv, nmod_t mod)
+                         mp_srcptr poly2, slong len2, mp_srcptr f,
+                         slong lenf, mp_srcptr finv, slong lenfinv, nmod_t mod)
 
     Sets \code{res} to the remainder of the product of \code{poly1} and
     \code{poly2} upon polynomial division by \code{f}.
@@ -715,7 +715,7 @@ void nmod_poly_div_basecase(nmod_poly_t
     exception is raised.
 
 void _nmod_poly_divrem_divconquer_recursive(mp_ptr Q, mp_ptr BQ, mp_ptr W,  
-                     mp_ptr V, mp_srcptr A, mp_srcptr B, slong lenB, nmod_t mod)
+                    mp_ptr V, mp_srcptr A, mp_srcptr B, slong lenB, nmod_t mod)
 
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R)$ less than 
     \code{lenB}, where \code{A} is of length \code{2 * lenB - 1} and \code{B} 
@@ -726,7 +726,7 @@ void _nmod_poly_divrem_divconquer_recurs
     coefficients computed by \code{NMOD_DIVREM_DC_ITCH(lenB, mod)}.
 
 void _nmod_poly_divrem_divconquer(mp_ptr Q, mp_ptr R, 
-                    mp_srcptr A, slong lenA, mp_srcptr B, slong lenB, nmod_t mod)
+                  mp_srcptr A, slong lenA, mp_srcptr B, slong lenB, nmod_t mod)
 
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R)$ less than 
     \code{lenB}, where \code{A} is of length \code{lenA} and \code{B} is of 
@@ -762,7 +762,7 @@ void _nmod_poly_divrem_q1(mp_ptr Q, mp_p
     Does not support aliasing or zero-padding.
 
 void _nmod_poly_divrem(mp_ptr Q, mp_ptr R, 
-                    mp_srcptr A, slong lenA, mp_srcptr B, slong lenB, nmod_t mod)
+                  mp_srcptr A, slong lenA, mp_srcptr B, slong lenB, nmod_t mod)
 
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R)$ less than 
     \code{lenB}, where \code{A} is of length \code{lenA} and \code{B} is of 
@@ -775,7 +775,7 @@ void nmod_poly_divrem(nmod_poly_t Q, nmo
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R) < \len(B)$.
 
 void _nmod_poly_div_divconquer_recursive(mp_ptr Q, mp_ptr W, mp_ptr V,
-                               mp_srcptr A, mp_srcptr B, slong lenB, nmod_t mod)
+                              mp_srcptr A, mp_srcptr B, slong lenB, nmod_t mod)
 
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R)$ less than 
     \code{lenB}, where \code{A} is of length \code{2 * lenB - 1} and \code{B} 
@@ -785,7 +785,7 @@ void _nmod_poly_div_divconquer_recursive
     coefficients computed by \code{NMOD_DIV_DC_ITCH(lenB, mod)}. 
 
 void _nmod_poly_div_divconquer(mp_ptr Q, mp_srcptr A, slong lenA, 
-                                            mp_srcptr B, slong lenB, nmod_t mod)
+                                           mp_srcptr B, slong lenB, nmod_t mod)
 
     Notionally computes polynomials $Q$ and $R$ such that $A = BQ + R$ with
     $\len(R)$ less than \code{lenB}, where \code{A} is of length \code{lenA} 
@@ -793,13 +793,13 @@ void _nmod_poly_div_divconquer(mp_ptr Q,
     require that \code{Q} have space for \code{lenA - lenB + 1} coefficients.
 
 void nmod_poly_div_divconquer(nmod_poly_t Q,
-                                      const nmod_poly_t A, const nmod_poly_t B)
+                                     const nmod_poly_t A, const nmod_poly_t B)
 
     Notionally computes $Q$ and $R$ such that $A = BQ + R$ with 
     $\len(R) < \len(B)$, but returns only $Q$.
 
 void _nmod_poly_div(mp_ptr Q, mp_srcptr A, slong lenA, 
-                                            mp_srcptr B, slong lenB, nmod_t mod)
+                                           mp_srcptr B, slong lenB, nmod_t mod)
 
     Notionally computes polynomials $Q$ and $R$ such that $A = BQ + R$ with
     $\len(R)$ less than \code{lenB}, where \code{A} is of length \code{lenA} 
@@ -977,7 +977,8 @@ void nmod_poly_divrem_newton(nmod_poly_t
     and compute the remainder.
 
 void _nmod_poly_divrem_newton21_preinv (mp_ptr Q, mp_ptr R, mp_srcptr A,
- slong lenA, mp_srcptr B, slong lenB, mp_srcptr Binv, slong lenBinv, nmod_t mod)
+                                   slong lenA, mp_srcptr B, slong lenB,
+                                    mp_srcptr Binv, slong lenBinv, nmod_t mod)
 
     Computes $Q$ and $R$ such that $A = BQ + R$ with $\len(R)$ less than 
     \code{lenB}, where $A$ is of length \code{lenA} and $B$ is of length 
@@ -1247,7 +1248,7 @@ void nmod_poly_compose_divconquer(nmod_p
     the divide and conquer algorithm.
 
 void _nmod_poly_compose(mp_ptr res, mp_srcptr poly1, slong len1, 
-                                        mp_srcptr poly2, slong len2, nmod_t mod)
+                                       mp_srcptr poly2, slong len2, nmod_t mod)
 
     Composes \code{poly1} of length \code{len1} with \code{poly2} of length
     \code{len2} and sets \code{res} to the result, i.e.\ evaluates \code{poly1}
